[{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/","tags":"","title":"Cours"},{"body":"Voici exemple de programmation déclarative et impérative en TypeScript:\n// typage implicite: la variable infère son type let i = 10; i = 20; // typage statique, on ne peut pas changer le type d'une variable //i = \"Hello\"; const items = [10, 34, -1, 44]; // const en TS empêche la réassignation (mais n'interdit pas la mutation) // items = [] // Style de programmation impératif const resultItems = []; for (const item of items) { if (item \u003e 0) { resultItems.push(item * 2); } } console.log(resultItems); // Style déclaratif =\u003e sortie = f(entrée) // Le code va refléter ou exprimer ce qu'on veut faire (et pas comment le faire) const filterdItems = items.filter((item) =\u003e item \u003e 0); console.log(filterdItems); const result2Items = filterdItems.map((item) =\u003e item * 2); console.log(result2Items); const result3Items = items.filter((item) =\u003e item \u003e 0).map((item) =\u003e item * 2); console.log(result3Items); Actuellement, la programmation impérative est généralement plus optimale que la programmation déclarative, mais ça dépend des compilateurs, des langages et du type de programme qu’on écrit. La programmation déclarative permet de plus facilement rendre son traitement asynchrone par sa façon de coder (c’est plus facile de rendre asynchrone les fonctions qu’on veut plutôt qu’un ensemble de code impératif) ","categories":"","description":"Programmation impérative et déclarative\n","excerpt":"Programmation impérative et déclarative\n","ref":"/docs/features/paradigmes/","tags":"","title":"Paradigmes de programmation d'UI"},{"body":"","categories":"","description":"Etudions quelques concepts\n","excerpt":"Etudions quelques concepts\n","ref":"/docs/features/","tags":"","title":"Concepts liés au développement desktop"},{"body":"Introduction Tout application démarre avec un seul processus et un seul thread d’exécution. Dans une application graphique, ce thread s’appelle le thread principal ou le thread UI et c’est lui qui gère l’affichage et les interactions avec l’utilisateur.\nSi on effectue des traitements longs (calcul d’un Fibonacci ou des nombres premiers) ou bloquants (attente de la réponse d’un serveur HTTP) dans le thread principal, il sera bloqué dans la partie “mise à jour de l’état de l’application”, causant ainsi un blocage de l’affichage et des interaction (les fameux freeze). C’est pour cela qu’on va effectuer ces traitements dans des threads. Ces derniers permettent de lancer des traitements en même temps sans bloquer le thread UI.\nLa programmation avec les threads fait partie d’un concept plus général appelé programmation asynchrone.\nLa programmation asynchrone La programmation asynchrone consiste à exécuter plusieurs traitements en même temps (en d’autres termes, je peux lancer une fonction et passer à la suite avant qu’elle se termine). En programmation, on écrit du code asynchrone via différntes API selon le langage: async await, promesses, threads, Rx (observables et observers), coroutines etc. Beaucoup des ces API créent ce qu’on peut qualifier des Thread virtuels. Ce sont des threads gérées par le programme et non par l’OS. Ceci permet de lancer plusieurs threads virtuels au sein d’un seul thread OS (on parle aussi de thread porteur). En Kotlin: les thread virtuel sont appelés coroutines. En C#: taches asynchrones En java: Thread virtuels Pourquoi faire des threads virtuels ? Car le coût d’un thread OS est élevé est on est limité par le nombre de thread OS qu’on peut créer à la fois. Cas particulier de JavaScript: un seul thread est utilisé pour faire de la programmation asynchrone (via un even Loop). On peut créer un équivalent de thread via les WebWorkers. ","categories":"","description":"Programmation asynchrone\n","excerpt":"Programmation asynchrone\n","ref":"/docs/features/async/","tags":"","title":"Programmation asynchrone"},{"body":"Ce projet a deux missions principales:\nDévelopper une application de bureau qui illustre les fonctionnalités typiques d’une application de bureau avec un Framework au choix Restituer une étude sur le Framework utilisé Développer une application de bureau Il vous est demandé de développer une application de bureau de type CRUD (Create, Read, Update, Delete) avec les contraintes suivantes:\nProposition d’un CRUD (4 pts) Persistance des données en local ou en ligne (4 pts) Affichage d’une liste de données (2 pts) Implémentation de deux fonctionnalités desktop natives (4 pts) Icône dans la barre d’état système (system tray) Service en arrière-plan Option pour démarrer automatiquement avec le système Menu contextuel (au clic droit) Compatible et fonctionnel avec au moins deux plateformes (vous pouvez utiliser WSL ou une VM) (2 pts) Publication sur un gestionnaire de paquêts (scoop, chocolatey, brew, etc.) (2 pts) Création d’un installeur qui ne nécessite pas les droits admin (2 pts) Restituer une étude sur le Framework utilisé Il vous est demandé de préparer une présentation autour du Framework de votre choix ainsi que votre application. Voici un modèle de plan à suivre:\nHistorique du framework Caractéristiques principales (plateformes supportés, langages, etc.) Ce qui le différencie de la concurrence Qui l’utilise / communauté Principe de fonctionnement du framework Présentation de l’application et de ses fonctionnalités Démo de l’application Evaluation et livrable L’évaluation se base sut votre présentation qui restitue votre étude du Framework utilisé ainsi qu’une démo de votre application. Les présentations auront lieu durant la dernière séance.\nIl vous est demandé de livrer la présentation ainsi que le code source de votre projet.\nQuelques Frameworks Tauri MAUI Electron Flutter Kotlin multiplatform (KMP) + Compose multiplatform QT (en C++ ou un langage alternatif) React Native for Windows + macOS JavaFX avalonia UNO Platfrom ","categories":"","description":"","excerpt":"Ce projet a deux missions principales:\nDévelopper une application de …","ref":"/docs/projet/","tags":"","title":"Projet"},{"body":" About Goldydocs A sample site using the Docsy Hugo theme.\nGoldydocs is a sample site using the Docsy Hugo theme that shows what it can do and provides you with a template site structure. It’s designed for you to clone and edit as much as you like. See the different sections of the documentation and site for more ideas.\nThis is another section This is another section ","categories":"","description":"","excerpt":" About Goldydocs A sample site using the Docsy Hugo theme.\nGoldydocs …","ref":"/about/","tags":"","title":"A propos"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/","tags":"","title":"Categories"},{"body":" Bienvenue au cours de développement d'applications de bureau ! Ce cours va surtout se focaliser sur les fonctionnalités inédites aux bureaux tels quels services. On va essayer d'être le plus agnostiques au niveau du Framework.\nVoir le cours ","categories":"","description":"","excerpt":" Bienvenue au cours de développement d'applications de bureau ! Ce …","ref":"/","tags":"","title":"Développement d'applications de bureau"},{"body":"","categories":"","description":"","excerpt":"","ref":"/search/","tags":"","title":"Search Results"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/","tags":"","title":"Tags"}]